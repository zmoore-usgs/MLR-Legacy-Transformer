# MLR-Legacy-Transformer
[![Build Status](https://travis-ci.org/USGS-CIDA/MLR-Legacy-Transformer.svg?branch=master)](https://travis-ci.org/USGS-CIDA/MLR-Legacy-Transformer)
[![Coverage Status](https://coveralls.io/repos/github/USGS-CIDA/MLR-Legacy-Transformer/badge.svg)](https://coveralls.io/github/USGS-CIDA/MLR-Legacy-Transformer)

## Service Description
This service is part of the MLR microservices and is responsible for performing various data transformations that must happen to an incoming location before that location is persisted in the database. Due to the way that DDot files are produced there are several pieces of data transmitted in the DDot file that are not necessarily in the proper format to be directly persisted into the Database. There are various software tools that are responsible for creating DDot files and all of them are older and not regularly maintained so making changes to each of them to perform these transformations was not an option. As a result, this service was created to be a catch-all for any transformations that we would have to make to incoming data (not all transformations were known when this srevice was created). As things went on it turned out that there were only two minor transformations that had to be done to DDot files, and as such this service is now being considered for removal and having the transformation logic performed in the Gateway or another service.

Currently the service performs the following two transformations:

1. Converting the raw station name into a normalized station name. This transformation removes certain special characters from the raw station name and normalizes the format and casing. This allows us to limit the number of inexact-duplicate station names in the database and ensure that we keep station names unique.

2. Converting the format of the Latitude and Longitude station coordinates to a decimal format. The database, and downstream applications which read from it, expects to store these coordinates in a decimal format but the DDot creation tools output these in a degree-minute-second format.

These transformations must occur before the duplicate validation performed by the Legacy CRU service as the normalized station name is not sent in with DDot file and it is used for that validation process.

The API methods for these transformations including expected inputs and result outputs can be examined in more detail in the Swagger API documentation for this service.

## Building and Running

This project has been built and tested with python 3.6.x. To build the project locally you will need
python 3 and virtualenv installed.
```bash
% virtualenv --python=python3 env
% env/bin/pip install -r requirements.txt
```
To run the tests:
```bash
env/bin/python -m unittest
```

To run the application locally execute the following:
```bash
% env/bin/python app.py
```

The swagger documentation can then be accessed at http://127.0.0.1:5000/api (when running locally using the above command).

Default configuration variables can be overridden be creating a .env file. For instance to turn debug on, 
you will want to create an .env with the following:
```python
DEBUG = True
```

For local development, you will need to provide a JWT token to the service. This can be done through the Swagger 
documents by clicking the Authorize button and entering 'Bearer your.jwt.token'.

You can use a valid JWT token generated by another service. You will need to set it's JWT_PUBLIC_KEY to the public 
key used to generate the token, as well as the JWT_DECODE_AUDIENCE (if any) and the JWT_ALGORITHM 
(if different than RS256). If you don't want to verify the cert on this service, set AUTH_CERT_PATH to False.

Alternatively, you can generate your own token by using the python package jwt. In the python interpreter, do the following
```python
import jwt
jwt.encode({'authorities': ['one_role', 'two_role']}, 'secret', algorithm='HS256')
```

The output of this command will be the token that you can use. You will need to set JWT_SECRET_KEY to 'secret' in 
your local .env file. See http://flask-jwt-simple.readthedocs.io/en/latest/options.html for the other options that 
you can use.

## Running with Docker 
This application can also be run locally using the docker container built during the build process, though this does not allow the application to be run in debug mode. The included `docker-compose` file has 2 profiles to choose from when running the application locally:

1. mlr-legacy-transformer: This is the default profile which runs the application as it would be in our cloud environment. This is not recommended for local development as it makes configuring connections to other services running locally on your machine more difficult.
2. mlr-legacy-transformer-local-dev: This is the profile which runs the application as it would be in the mlr-local-dev project, and is configured to make it easy to replace the mlr-legacy-transformer instance in the local-dev project with this instance. It is run the same as the `mlr-legacy-transformer` profile, except it uses the docker host network driver.

Before any of these options are able to be run you must also generate certificates for this application to serve using the `create_certificates` script in the `docker/certificates` directory. Additionally, this service must be able to connect to a running instance of Water Auth when starting, and it is recommended that you use the Water Auth instance from the `mlr-local-dev` project to accomplish this. In order for this application to communicate with any downstream services that it must call, including Water Auth, you must also place the certificates that are being served by those services into the `docker/certificates/import_certs` directory to be imported into the Python CA Certificates of the running container.

To build and run the application after completing the above steps you can run: `docker-compose up --build {profile}`, replacing `{profile}` with one of the options listed above.

The swagger documentation can then be accessed at http://127.0.0.1:6020/api